<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    {% seo %}

    <!-- CSS -->
    <link rel="stylesheet" href="{{ "/assets/main.css" | relative_url }}?v={{ site.time | date: '%s' }}">
    
    <!-- Google Fonts - Optimized loading -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Lora:ital,wght@0,400;0,500;0,600;1,400&family=JetBrains+Mono:wght@400;500&family=Space+Grotesk:wght@500;600;700&display=swap" rel="stylesheet">

    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="32x32" href="{{ "/assets/favicon-32x32.png" | relative_url }}">
    <link rel="icon" type="image/png" sizes="16x16" href="{{ "/assets/favicon-16x16.png" | relative_url }}">
    <link rel="apple-touch-icon" sizes="180x180" href="{{ "/assets/apple-touch-icon.png" | relative_url }}">
    <link rel="manifest" href="{{ "/assets/site.webmanifest" | relative_url }}">

    <!-- RSS -->
    {% feed_meta %}

    <!-- Mermaid -->
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'dark',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            themeVariables: {
                // Dark theme colors matching blog design
                darkMode: true,
                background: '#1a1a1a',
                primaryColor: '#14b8a6',
                primaryTextColor: '#e4e4e4',
                primaryBorderColor: '#14b8a6',
                lineColor: '#6c6c6c',
                secondaryColor: '#2d2d2d',
                tertiaryColor: '#1f1f1f',
                edgeLabelBackground: '#2d2d2d',
                clusterBkg: '#343030',
                clusterBorder: '#14b8a6',
                defaultLinkColor: '#f59e0b',
                titleColor: '#ffffff',
                errorBkgColor: '#f97316',
                errorTextColor: '#ffffff',
                mainBkg: '#2d2d2d',
                mainBorder: '#14b8a6',
                nodeTextColor: '#e4e4e4',
                nodeBkg: '#2d2d2d',
                nodeBorder: '#14b8a6',
                labelBackground: '#343030',
                labelBorder: '#6c6c6c',
                labelTextColor: '#e4e4e4',
                loopTextColor: '#e4e4e4',
                noteBkgColor: '#f59e0b',
                noteTextColor: '#1a1a1a',
                noteBorderColor: '#f59e0b',
                sectionBkgColor: '#1f1f1f',
                sectionBkgColor2: '#343030',
                sectionStroke: '#14b8a6',
                sectionStrokeWidth: 2,
                gridColor: '#6c6c6c',
                altBackground: '#343030',
                altSectionBkgColor: '#2d2d2d',
                classText: '#e4e4e4',
                fillType0: '#2d2d2d',
                fillType1: '#14b8a6',
                fillType2: '#f59e0b',
                fillType3: '#f97316',
                fillType4: '#343030',
                fillType5: '#1f1f1f',
                fillType6: '#6c6c6c',
                fillType7: '#ffffff'
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            mermaid.init(undefined, '.mermaid');
            
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.type === 'childList') {
                        const mermaidElements = mutation.target.querySelectorAll('.mermaid');
                        if (mermaidElements.length > 0) {
                            mermaid.init(undefined, '.mermaid');
                        }
                    }
                });
            });
            
            observer.observe(document.body, {
                childList: true,
                subtree: true
            });
        });
    </script>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-32700356-3"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());

        gtag('config', 'UA-32700356-3');
    </script>

    <!-- Heading copy functionality -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            var headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

            headings.forEach(function(heading) {
                heading.addEventListener('click', function() {
                    var id = heading.id;
                    if (!id) return;

                    var offset = 20;
                    var top = heading.getBoundingClientRect().top + window.pageYOffset - offset;
                    window.scrollTo({
                        top: top,
                        behavior: 'smooth'
                    });

                    var url = location.origin + location.pathname + '#' + id;

                    if (navigator.clipboard && window.isSecureContext) {
                        navigator.clipboard.writeText(url).then(function() {
                            showCopyFeedback(heading, 'Link copied!');
                        }).catch(function(err) {
                            fallbackCopyTextToClipboard(url);
                            showCopyFeedback(heading, 'Link copied!');
                        });
                    } else {
                        fallbackCopyTextToClipboard(url);
                        showCopyFeedback(heading, 'Link copied!');
                    }
                });
            });

            function showCopyFeedback(heading, message) {
                var existing = heading.querySelector('.copy-feedback');
                if (existing) {
                    existing.remove();
                }

                var feedback = document.createElement('span');
                feedback.className = 'copy-feedback';
                feedback.textContent = ' [' + message + ']';
                feedback.style.color = '#14b8a6';
                feedback.style.fontSize = '0.6em';
                feedback.style.fontFamily = 'monospace';
                feedback.style.opacity = '0';
                feedback.style.transition = 'opacity 0.2s ease';

                heading.appendChild(feedback);

                requestAnimationFrame(() => {
                    feedback.style.opacity = '1';
                });

                setTimeout(function() {
                    feedback.style.opacity = '0';
                    setTimeout(function() {
                        if (feedback.parentNode) {
                            feedback.parentNode.removeChild(feedback);
                        }
                    }, 200);
                }, 2000);
            }

            function fallbackCopyTextToClipboard(text) {
                var textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.top = '0';
                textArea.style.left = '0';
                textArea.style.width = '2em';
                textArea.style.height = '2em';
                textArea.style.padding = '0';
                textArea.style.border = 'none';
                textArea.style.outline = 'none';
                textArea.style.boxShadow = 'none';
                textArea.style.background = 'transparent';
                textArea.style.opacity = '0';
                textArea.style.zIndex = '-1';

                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();

                try {
                    document.execCommand('copy');
                } catch (err) {
                    console.error('Fallback: Oops, unable to copy', err);
                }

                document.body.removeChild(textArea);
            }
        });
    </script>

    <!-- Table of Contents -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            function generateTOC() {
                const postContent = document.querySelector('.post-content');
                if (!postContent) return;

                const headings = postContent.querySelectorAll('h2, h3, h4, h5, h6');
                if (headings.length === 0) return;

                const tocMobile = document.getElementById('toc-mobile');
                const tocDesktop = document.getElementById('toc-desktop');

                if (!tocMobile || !tocDesktop) return;

                // Create TOC structure
                const tocTitle = document.createElement('div');
                tocTitle.className = 'toc-title';
                tocTitle.textContent = 'Table of Contents';

                const tocList = document.createElement('ul');
                tocList.className = 'toc-list';

                let tocHTML = '';
                headings.forEach(function(heading, index) {
                    // Generate ID if not exists
                    let id = heading.id;
                    if (!id) {
                        id = 'heading-' + index;
                        heading.id = id;
                    }

                    // Create slug from text if needed
                    if (id.startsWith('heading-')) {
                        const text = heading.textContent.trim().toLowerCase()
                            .replace(/[^\w\s-]/g, '')
                            .replace(/\s+/g, '-')
                            .replace(/-+/g, '-');
                        id = text || 'heading-' + index;
                        heading.id = id;
                    }

                    const level = parseInt(heading.tagName.charAt(1));
                    const indent = (level - 2) * 1.5; // h2 = 0, h3 = 1.5rem, etc.

                    tocHTML += '<li class="toc-item toc-level-' + level + '" style="padding-left: ' + indent + 'rem;">';
                    tocHTML += '<a href="#' + id + '" class="toc-link" data-target="' + id + '">';
                    tocHTML += heading.textContent.trim();
                    tocHTML += '</a></li>';
                });

                tocList.innerHTML = tocHTML;

                // Helper to build TOC wrapper with scrollable list container
                function appendTOC(target, isDesktop) {
                    if (!target) return;

                    const wrapper = document.createElement('div');
                    wrapper.className = 'toc-wrapper';

                    const title = tocTitle.cloneNode(true);
                    const listContainer = document.createElement('div');
                    listContainer.className = 'toc-list-container';
                    const listClone = tocList.cloneNode(true);
                    listContainer.appendChild(listClone);

                    wrapper.appendChild(title);
                    wrapper.appendChild(listContainer);

                    if (isDesktop) {
                        // Create container for desktop TOC
                        const container = document.createElement('div');
                        container.className = 'toc-container';
                        container.appendChild(wrapper);
                        target.appendChild(container);

                        // Function to check if we're on a large screen
                        function isLargeScreen() {
                            return window.innerWidth >= 1400;
                        }

                        // Function to setup TOC based on screen size
                        function setupTOC() {
                            if (isLargeScreen()) {
                                // Large screen: always show TOC, no toggle button
                                target.classList.remove('hidden');
                                container.classList.add('visible');
                                // Remove toggle button if it exists
                                const existingToggle = target.querySelector('.toc-toggle');
                                if (existingToggle) {
                                    existingToggle.remove();
                                }
                            } else {
                                // Medium screen: use toggle functionality
                                let toggleButton = target.querySelector('.toc-toggle');
                                
                                if (!toggleButton) {
                                    // Create toggle button
                                    toggleButton = document.createElement('button');
                                    toggleButton.className = 'toc-toggle';
                                    toggleButton.setAttribute('aria-label', 'Toggle Table of Contents');
                                    target.insertBefore(toggleButton, container);
                                }

                                // Toggle functionality
                                const isHidden = localStorage.getItem('toc-desktop-hidden') !== 'false'; // Default to hidden
                                if (isHidden) {
                                    target.classList.add('hidden');
                                    // Left arrow when hidden (click to show)
                                    toggleButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>';
                                } else {
                                    container.classList.add('visible');
                                    // Right arrow when visible (click to hide)
                                    toggleButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/></svg>';
                                }

                                // Remove existing listeners by cloning and replacing
                                const newToggleButton = toggleButton.cloneNode(true);
                                toggleButton.parentNode.replaceChild(newToggleButton, toggleButton);

                                newToggleButton.addEventListener('click', function() {
                                    const isCurrentlyHidden = target.classList.contains('hidden');
                                    if (isCurrentlyHidden) {
                                        target.classList.remove('hidden');
                                        container.classList.add('visible');
                                        // Right arrow when visible (click to hide)
                                        newToggleButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z"/></svg>';
                                        localStorage.setItem('toc-desktop-hidden', 'false');
                                    } else {
                                        target.classList.add('hidden');
                                        container.classList.remove('visible');
                                        // Left arrow when hidden (click to show)
                                        newToggleButton.innerHTML = '<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z"/></svg>';
                                        localStorage.setItem('toc-desktop-hidden', 'true');
                                    }
                                });
                            }
                        }

                        // Initial setup
                        setupTOC();

                        // Handle window resize
                        let resizeTimeout;
                        window.addEventListener('resize', function() {
                            clearTimeout(resizeTimeout);
                            resizeTimeout = setTimeout(setupTOC, 150);
                        });
                    } else {
                        target.appendChild(wrapper);
                    }
                }

                appendTOC(tocMobile, false);
                appendTOC(tocDesktop, true);

                // Smooth scroll for TOC links
                const tocLinks = document.querySelectorAll('.toc-link');
                tocLinks.forEach(function(link) {
                    link.addEventListener('click', function(e) {
                        e.preventDefault();
                        const targetId = this.getAttribute('data-target');
                        const targetElement = document.getElementById(targetId);
                        if (targetElement) {
                            const offset = 100;
                            const top = targetElement.getBoundingClientRect().top + window.pageYOffset - offset;
                            window.scrollTo({
                                top: top,
                                behavior: 'smooth'
                            });
                        }
                    });
                });

                // Scroll highlighting with improved algorithm
                function updateActiveTOCItem() {
                    const scrollPosition = window.scrollY;
                    const viewportHeight = window.innerHeight;
                    const offset = 200; // Offset from top of viewport
                    
                    let currentHeading = null;
                    let minDistance = Infinity;

                    // Find the heading closest to the top of viewport (with offset)
                    headings.forEach(function(heading) {
                        const rect = heading.getBoundingClientRect();
                        const headingTop = scrollPosition + rect.top;
                        const distance = Math.abs(headingTop - (scrollPosition + offset));

                        // Heading is above the offset point and closer than previous
                        if (rect.top <= offset && distance < minDistance) {
                            minDistance = distance;
                            currentHeading = heading;
                        }
                    });

                    // If no heading found above offset, use the first visible one
                    if (!currentHeading) {
                        headings.forEach(function(heading) {
                            const rect = heading.getBoundingClientRect();
                            if (rect.top >= 0 && rect.top <= viewportHeight) {
                                if (!currentHeading || rect.top < currentHeading.getBoundingClientRect().top) {
                                    currentHeading = heading;
                                }
                            }
                        });
                    }

                    // Update active state smoothly
                    tocLinks.forEach(function(link) {
                        const wasActive = link.classList.contains('active');
                        const shouldBeActive = currentHeading && link.getAttribute('data-target') === currentHeading.id;
                        
                        if (wasActive !== shouldBeActive) {
                            if (shouldBeActive) {
                                link.classList.add('active');
                                // Scroll active item into view in desktop TOC (only if needed and visible)
                                const tocDesktop = document.getElementById('toc-desktop');
                                const desktopListContainer = document.querySelector('.toc-desktop .toc-list-container');
                                if (desktopListContainer && desktopListContainer.contains(link) && window.innerWidth >= 1024 && 
                                    tocDesktop && !tocDesktop.classList.contains('hidden')) {
                                    const containerHeight = desktopListContainer.clientHeight;
                                    const containerScrollTop = desktopListContainer.scrollTop;
                                    const linkTop = link.offsetTop;
                                    const linkBottom = linkTop + link.offsetHeight;

                                    if (linkTop < containerScrollTop) {
                                        desktopListContainer.scrollTo({ top: Math.max(linkTop - 24, 0), behavior: 'smooth' });
                                    } else if (linkBottom > containerScrollTop + containerHeight) {
                                        desktopListContainer.scrollTo({ top: linkBottom - containerHeight + 24, behavior: 'smooth' });
                                    }
                                }
                            } else {
                                link.classList.remove('active');
                            }
                        }
                    });
                }

                // Optimized scroll handler with requestAnimationFrame
                let lastScrollTop = 0;
                let ticking = false;
                
                function handleScroll() {
                    const currentScrollTop = window.pageYOffset || document.documentElement.scrollTop;
                    
                    if (!ticking) {
                        window.requestAnimationFrame(function() {
                            // Only update if scroll position changed significantly
                            if (Math.abs(currentScrollTop - lastScrollTop) > 5) {
                                updateActiveTOCItem();
                                lastScrollTop = currentScrollTop;
                            }
                            ticking = false;
                        });
                        ticking = true;
                    }
                }

                window.addEventListener('scroll', handleScroll, { passive: true });
                
                // Initial update after a short delay to ensure DOM is ready
                setTimeout(function() {
                    updateActiveTOCItem();
                }, 100);
            }

            generateTOC();
        });
    </script>
</head>